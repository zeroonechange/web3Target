Calldata 

Function: multicall(bytes[] data)

MethodID: 0xac9650d8
[0]:  0000000000000000000000000000000000000000000000000000000000000020

[1]:  0000000000000000000000000000000000000000000000000000000000000003

[2]:  0000000000000000000000000000000000000000000000000000000000000060
[3]:  0000000000000000000000000000000000000000000000000000000000000120
[4]:  00000000000000000000000000000000000000000000000000000000000002c0

[5]:  0000000000000000000000000000000000000000000000000000000000000084
[6]:  13ead56200000000000000000000000061fe7a5257b963f231e1ef6e22cb3b4c
[7]:  6e28c531000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead908
[8]:  3c756cc200000000000000000000000000000000000000000000000000000000
[9]:  00002710000000000000000000000000000000000000000000831162ce86bc88
[10]: 052f80fd00000000000000000000000000000000000000000000000000000000

[11]: 0000000000000000000000000000000000000000000000000000000000000164
[12]: 8831645600000000000000000000000061fe7a5257b963f231e1ef6e22cb3b4c
[13]: 6e28c531000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead908
[14]: 3c756cc200000000000000000000000000000000000000000000000000000000
[15]: 00002710ffffffffffffffffffffffffffffffffffffffffffffffffffffffff
[16]: fffaf17800000000000000000000000000000000000000000000000000000000
[17]: 0000000000000000000000000000000000000000000000000002e3bdc2534919
[18]: 6582d720000000000000000000000000000000000000000000000000c249fdd3
[19]: 2778000000000000000000000000000000000000000000000002e1e525c2ef9d
[20]: cec50c53000000000000000000000000000000000000000000000000c1cd7c9a
[21]: dfb0d9dc000000000000000000000000ed6c2cb9bf89a2d290e59025837454bf
[22]: 1f144c5000000000000000000000000000000000000000000000000000000000
[23]: 635ce8bf00000000000000000000000000000000000000000000000000000000

[24]: 0000000000000000000000000000000000000000000000000000000000000004
[25]: 12210e8a00000000000000000000000000000000000000000000000000000000



MethodID: 0xac9650d8
// offset of array_1 (starting next line)
0000000000000000000000000000000000000000000000000000000000000020
// length of array_1 (how many elements in array)
0000000000000000000000000000000000000000000000000000000000000003
// offset of 1st element in array_1, array_1A (96-bytes / 32 = 3)
0000000000000000000000000000000000000000000000000000000000000060
// offset of 2nd element in array_1, array_1B (288-bytes / 32 = 9)
0000000000000000000000000000000000000000000000000000000000000120
// offset of 3rd element in array_1, array_1C (704-bytes / 32 = 22)
00000000000000000000000000000000000000000000000000000000000002c0

// length 1st element of array_1, array_1A (132-bytes (inc. selector))
0000000000000000000000000000000000000000000000000000000000000084

// here we'll read the next 132-bytes
// fn selector; 4 of 132
13ead562
// 1st param; 36 of 132
00000000000000000000000061fe7a5257b963f231e1ef6e22cb3b4c6e28c531
// 2nd param; 68 of 132
000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
// 3rd param; 100 of 132
0000000000000000000000000000000000000000000000000000000000002710
// 4th param; 132 of 132
// this marks the end of array_1A
000000000000000000000000000000000000000000831162ce86bc88052f80fd

// 32-bytes of `0` indicating next elemet
0000000000000000000000000000000000000000000000000000000000000000
// length 2nd element of array_1, array_1B (356-bytes (inc. selector))
// we have 4-bytes missing due to the embedded fn selector, 13ead562
// the next fn selector, 88316456, will be inserted here
00000000000000000000000000000000000000000000000000000164

// here we'll read the next 356-bytes
// fn selector; 4 of 356
88316456
// 1st param; 36 of 356
00000000000000000000000061fe7a5257b963f231e1ef6e22cb3b4c6e28c531
// 2nd param; 68 of 356
000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
// 3rd param; 100 of 356
0000000000000000000000000000000000000000000000000000000000002710
// 4th param; 132 of 356
// notice how all the `0`s are `f`s. this indicates a `int` type!
fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffaf178
// 5th param; 164 of 356
// we have 32-bytes of `0`, but since we're still reading the bytes
// we know this is a paramter, representing 0 of a type
0000000000000000000000000000000000000000000000000000000000000000
// 6th param; 196 of 356
00000000000000000000000000000000000000000002e3bdc25349196582d720
// 7th param; 228 of 356
000000000000000000000000000000000000000000000000c249fdd327780000
// 8th param; 260 of 356
00000000000000000000000000000000000000000002e1e525c2ef9dcec50c53
// 9th param; 292 of 356
000000000000000000000000000000000000000000000000c1cd7c9adfb0d9dc
// 10th param; 324 of 356
000000000000000000000000ed6c2cb9bf89a2d290e59025837454bf1f144c50
// 11th param; 356 of 356
// this marks the end of array_1B
00000000000000000000000000000000000000000000000000000000635ce8bf

// 32-bytes of `0` indicating next elemet
0000000000000000000000000000000000000000000000000000000000000000
// this is the same thing as before, the length!
// we can see there's only 32-bytes left so we can conclude
// that it's going to be a fn with no inputs
00000000000000000000000000000000000000000000000000000004

// a call to the fn selector 12210e8a; 4 of 4
12210e8a00000000000000000000000000000000000000000000000000000000






ABI 书上的         

        合约一写完 编译ok 交给EVM执行 交易的输入数据 calldata 是一个字节序列 如何解释这玩意？
        这个规则就是 二进制接口规范 Application binary interface - ABI 
        合约执行时的内存结构:
                        0x00 ~ 0x3f  为哈希方法保留空间 
                        0x40 ~ 0x5f  当前分配的内存大小 
                        0x60 ~ 0x7f         初始值为0的储存槽

        calldata 的前4个字节是 function selector = bytes4( keccak256("函数名(参数)")) 参数的数据从第5个字节开始   
        例如   function add(uint256 a, uint256 b) public view returns (uint256 result)  
        function selector = bytes4( keccak256("add(uint256,uint256)"))  其实就是哈希后 截取前4个字节 也就是16进制长度为8 

        EVM中 sstore 耗费 20_000 gas 是基本算数运算的 5_000 倍  
                  sload  耗费 200 gas    是基本算数运算的 100   倍

        mapping 
                        例如  mapping(uint256 -> uint256) mapitems;   -->   mapitems[0x5f0f9b3e] = 0x3f 
                        其汇编代码为:
                                        PUSH1 0x3f 
                                        PUSH32 0xcccccccccccccccccccccccccc
                                        SSTORE
                        在 地址 0xcccccccccccccccccccccccccc 存入 0x3f  那么这个 0xcccccccccccccccccccccccccc 是如何得到的呢?
                        计算公式  keccak256(bytes32(key) + bytes32(position))  
                        '0xcccccccccccccccccccccccccc' = keccak256(bytes32('0x5f0f9b3e') + bytes32(0)) 
                        由 key 和 position 去确定 storage slot 的位置 

        那如果是结构体呢 例如 
                        mapping(uint256 -> Tuple) maptuples;
                        struct Tuple{
                                        uint256 a;
                                        uint256 b;
                                        uint256 c;
                        }
                        maptuples[0x1].a = 0x1A;
                        maptuples[0x1].b = 0x1B;
                        maptuples[0x1].c = 0x1C;
                        
                        汇编代码:
                                        PUSH1 0x1A
                                        PUSH32 0xcccccccccccccccccccccccc7d
                                        SSTORE
                                        PUSH1 0x1B
                                        PUSH32 0xcccccccccccccccccccccccc7e
                                        SSTORE
                                        PUSH1 0x1C
                                        PUSH32 0xcccccccccccccccccccccccc7f
                                        SSTORE
                        计算公式 keccak256(bytes32('0x1') + bytes32(0))  = 0xcccccccccccccccccccccccc7d
                        后面三个 就紧密排列  slot 累加  
                        
                        如果是动态数组呢 
                                        uint256[] array1;
                                        array1.push(0xAA);
                                        array1.push(0xBB);
                                        array1.push(0xCC);
                        key: 0x0000000000000000000000000000000000000000000000000000000000000000
                  value: 0x0000000000000000000000000000000000000000000000000000000000000003
                        key: 0xcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc63
              value: 0x00000000000000000000000000000000000000000000000000000000000000aa          
                        key: 0xcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc64
              value: 0x00000000000000000000000000000000000000000000000000000000000000bb
                        key: 0xcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc65
              value: 0x00000000000000000000000000000000000000000000000000000000000000cc          
          slot 0  存放的是数组长度  
          后面的地址是 keccak256(bytes32(0)) = 0xcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc63 
          紧密排列 依次累加 
          
          比如一个合约 
                        contract example{
                                        uint256 obj;
                                        function setobj(uint256 para) public{
                                                        obj = para;
                                        }
                                        function getobj() public returns(uint256){
                                                        return obj;
                                        }
                        }
        如果想通过abi 去调用 setobj(100)  那么 calldata 应该是由俩部分组成

        1. function selector = bytes4( keccak256("setobj(uint256)")) = 0x5f0f9b3e
        2. 参数  0000000000000000000000000000000000000000000000000000000000000064 

        合起来   calldata = 0x5f0f9b3e0000000000000000000000000000000000000000000000000000000000000064

        反编译这个合约代码  solc --bin --asm --optimize example.sol 
        得到汇编代码  这里脑壳痛  后面再学 先记点东西 

        汇编:
                        PUSH1  PUSH32
                        SSTORE
                        
                        mstore
                        jumpi(tag_1, lt(calldatasize, 0x4)))
                        and(div(calldataload(0x0), 0x10000000000), 0xffffffff)
                        dup2
                        eq
                        jumpi 

        abi实例
                        1.固定大小 
                        encode_abi(["uint256","uint256","uint256"], [1,2,3]).hex()
                        000000000000000000000000000000000000000000000000000000001
                        000000000000000000000000000000000000000000000000000000002
                        000000000000000000000000000000000000000000000000000000003

                        encode_abi(["int8","uint32","uint64"], [1,2,3]).hex()
                        000000000000000000000000000000000000000000000000000000001
                        000000000000000000000000000000000000000000000000000000002
                        000000000000000000000000000000000000000000000000000000003
                        
                        encode_abi(["int8[3]","int256[3]"], [[1,2,3],[4,5,6]]).hex()
                        000000000000000000000000000000000000000000000000000000001
                        000000000000000000000000000000000000000000000000000000002
                        000000000000000000000000000000000000000000000000000000003
                        000000000000000000000000000000000000000000000000000000004
                        000000000000000000000000000000000000000000000000000000005
                        000000000000000000000000000000000000000000000000000000006
                        
                        encode_abi(["uint256[]","uint256[]","uint256[]"], [[0xd1,0xd2,0xd3],[0xe1,0xe2,0xe3],[0xf1,0xf2,0xf3]]).hex()
                        000000000000000000000000000000000000000000000000000000006
                        00000000000000000000000000000000000000000000000000000000e
                        000000000000000000000000000000000000000000000000000000016
                        000000000000000000000000000000000000000000000000000000003
                        0000000000000000000000000000000000000000000000000000000d1
                        0000000000000000000000000000000000000000000000000000000d2
                        0000000000000000000000000000000000000000000000000000000d3
                        000000000000000000000000000000000000000000000000000000003
                        0000000000000000000000000000000000000000000000000000000e1
                        0000000000000000000000000000000000000000000000000000000e2
                        0000000000000000000000000000000000000000000000000000000e3
                        000000000000000000000000000000000000000000000000000000003
                        0000000000000000000000000000000000000000000000000000000f1
                        0000000000000000000000000000000000000000000000000000000f2
                        0000000000000000000000000000000000000000000000000000000f3
                        这个有点特别  06 0e 16 分别指向数组的头  第一个总是长度  后面紧凑排列的值                         


                        
doc文档                                

        变长和定长 不一样   例如 function(a,b,c)  
        如果 a 是定长  直接占用 32个字节   一个slot 
        如果 a 是变长  则先把a里面的参数 给弄成 slot[] 然后a存放偏移量  就是 第四行 
        大体规则是 多少个参数  如果是定长 则32个字节直接放  变长放不下的 放偏移量  指向实际的数据
        
        比如 a = string[] -> ["one", "two", "three"]
                0 - c                                                                - "one" 的偏移量
                1 - d                                                                - "two" 的偏移量
                2 - e                                                                - "three" 的偏移量
                3 - 0000000000000000000000000000000000000000000000000000000000000003 - "one" 的字符计数
                4 - 6f6e650000000000000000000000000000000000000000000000000000000000 - "one" 的编码
                5 - 0000000000000000000000000000000000000000000000000000000000000003 - "two" 的字符计数
                6 - 74776f0000000000000000000000000000000000000000000000000000000000 - "two" 的编码
                7 - 0000000000000000000000000000000000000000000000000000000000000005 - "three" 的字符计数
                8 - 7468726565000000000000000000000000000000000000000000000000000000 - "three" 的编码

        来个例子吧  非常长:
                对一个签名为 g(uint[][],string[])，参数值为 ([[1, 2], [3]], ["one", "two", "three"]) 的函数来进行编码；但从最原子的部分开始：
                首先我们将第一个根数组 [[1, 2], [3]] 的第一个嵌入的动态数组 [1, 2] 的长度和数据进行编码：
                        0x0000000000000000000000000000000000000000000000000000000000000002 (第一个数组中的元素数量 2；元素本身是 1 和 2)
                        0x0000000000000000000000000000000000000000000000000000000000000001 (第一个元素)
                        0x0000000000000000000000000000000000000000000000000000000000000002 (第二个元素)
                然后我们将第一个根数组 [[1, 2], [3]] 的第二个潜入的动态数组 [3] 的长度和数据进行编码：
                        0x0000000000000000000000000000000000000000000000000000000000000001 (第二个数组中的元素数量 1；元素数据是 3)
                        0x0000000000000000000000000000000000000000000000000000000000000003 (第一个元素)
                然后我们需要找到动态数组 [1, 2] 和 [3] 的偏移量。要计算这个偏移量，我们可以来看一下第一个根数组 [[1, 2], [3]] 编码后的具体数据：
                        0 - a                                                                - [1, 2] 的偏移量
                        1 - b                                                                - [3] 的偏移量
                        2 - 0000000000000000000000000000000000000000000000000000000000000002 - [1, 2] 的计数
                        3 - 0000000000000000000000000000000000000000000000000000000000000001 - 1 的编码
                        4 - 0000000000000000000000000000000000000000000000000000000000000002 - 2 的编码
                        5 - 0000000000000000000000000000000000000000000000000000000000000001 - [3] 的计数
                        6 - 0000000000000000000000000000000000000000000000000000000000000003 - 3 的编码
                偏移量 a 指向数组 [1, 2] 内容的开始位置，即第 2 行的开始（64 字节）；所以 a = 0x0000000000000000000000000000000000000000000000000000000000000040。
                偏移量 b 指向数组 [3] 内容的开始位置，即第 5 行的开始（160 字节）；所以 b = 0x00000000000000000000000000000000000000000000000000000000000000a0。
                然后我们对第二个根数组的嵌入字符串进行编码：
                        0x0000000000000000000000000000000000000000000000000000000000000003 (单词 "one" 中的字符个数)
                        0x6f6e650000000000000000000000000000000000000000000000000000000000 (单词 "one" 的 utf8 编码)
                        0x0000000000000000000000000000000000000000000000000000000000000003 (单词 "two" 中的字符个数)
                        0x74776f0000000000000000000000000000000000000000000000000000000000 (单词 "two" 的 utf8 编码)
                        0x0000000000000000000000000000000000000000000000000000000000000005 (单词 "three" 中的字符个数)
                        0x7468726565000000000000000000000000000000000000000000000000000000 (单词 "three" 的 utf8 编码)
                作为与第一个根数组的并列，因为字符串也属于动态元素，我们也需要找到它们的偏移量 c, d 和 e：
                        0 - c                                                                - "one" 的偏移量
                        1 - d                                                                - "two" 的偏移量
                        2 - e                                                                - "three" 的偏移量
                        3 - 0000000000000000000000000000000000000000000000000000000000000003 - "one" 的字符计数
                        4 - 6f6e650000000000000000000000000000000000000000000000000000000000 - "one" 的编码
                        5 - 0000000000000000000000000000000000000000000000000000000000000003 - "two" 的字符计数
                        6 - 74776f0000000000000000000000000000000000000000000000000000000000 - "two" 的编码
                        7 - 0000000000000000000000000000000000000000000000000000000000000005 - "three" 的字符计数
                        8 - 7468726565000000000000000000000000000000000000000000000000000000 - "three" 的编码
                偏移量 c 指向字符串 "one" 内容的开始位置，即第 3 行的开始（96 字节）；所以 c = 0x0000000000000000000000000000000000000000000000000000000000000060。
                偏移量 d 指向字符串 "two" 内容的开始位置，即第 5 行的开始（160 字节）；所以 d = 0x00000000000000000000000000000000000000000000000000000000000000a0。
                偏移量 e 指向字符串 "three" 内容的开始位置，即第 7 行的开始（224 字节）；所以 e = 0x00000000000000000000000000000000000000000000000000000000000000e0。
                注意，根数组的嵌入元素的编码并不互相依赖，且具有对于函数签名 g(string[],uint[][]) 所相同的编码。
                然后我们对第一个根数组的长度进行编码：
                        0x0000000000000000000000000000000000000000000000000000000000000002 (第一个根数组的元素数量 2；这些元素本身是 [1, 2] 和 [3])
                而后我们对第二个根数组的长度进行编码：
                        0x0000000000000000000000000000000000000000000000000000000000000003 (第二个根数组的元素数量 3；这些字符串本身是 "one"、"two" 和 "three")
                最后，我们找到根动态数组元素 [[1, 2], [3]] 和 ["one", "two", "three"] 的偏移量 f 和 g。汇编数据的正确顺序如下：
                        0x2289b18c                                                            - 函数签名
                         0 - f                                                                - [[1, 2], [3]] 的偏移量
                         1 - g                                                                - ["one", "two", "three"] 的偏移量
                         2 - 0000000000000000000000000000000000000000000000000000000000000002 - [[1, 2], [3]] 的元素计数
                         3 - 0000000000000000000000000000000000000000000000000000000000000040 - [1, 2] 的偏移量
                         4 - 00000000000000000000000000000000000000000000000000000000000000a0 - [3] 的偏移量
                         5 - 0000000000000000000000000000000000000000000000000000000000000002 - [1, 2] 的元素计数
                         6 - 0000000000000000000000000000000000000000000000000000000000000001 - 1 的编码
                         7 - 0000000000000000000000000000000000000000000000000000000000000002 - 2 的编码
                         8 - 0000000000000000000000000000000000000000000000000000000000000001 - [3] 的元素计数
                         9 - 0000000000000000000000000000000000000000000000000000000000000003 - 3 的编码
                        10 - 0000000000000000000000000000000000000000000000000000000000000003 - ["one", "two", "three"] 的元素计数
                        11 - 0000000000000000000000000000000000000000000000000000000000000060 - "one" 的偏移量
                        12 - 00000000000000000000000000000000000000000000000000000000000000a0 - "two" 的偏移量
                        13 - 00000000000000000000000000000000000000000000000000000000000000e0 - "three" 的偏移量
                        14 - 0000000000000000000000000000000000000000000000000000000000000003 - "one" 的字符计数
                        15 - 6f6e650000000000000000000000000000000000000000000000000000000000 - "one" 的编码
                        16 - 0000000000000000000000000000000000000000000000000000000000000003 - "two" 的字符计数
                        17 - 74776f0000000000000000000000000000000000000000000000000000000000 - "two" 的编码
                        18 - 0000000000000000000000000000000000000000000000000000000000000005 - "three" 的字符计数
                        19 - 7468726565000000000000000000000000000000000000000000000000000000 - "three" 的编码
                偏移量 f 指向数组 [[1, 2], [3]] 内容的开始位置，即第 2 行的开始（64 字节）；所以 f = 0x0000000000000000000000000000000000000000000000000000000000000040。
                偏移量 g 指向数组 ["one", "two", "three"] 内容的开始位置，即第 10 行的开始（320 字节）；所以 g = 0x0000000000000000000000000000000000000000000000000000000000000140。

        还是doc文档写的比较清楚  全面    简单来说 简单的直接放 复杂的弄个偏移量，类似于指针，放在后面 按照递归一样的规则，层级存放数据 